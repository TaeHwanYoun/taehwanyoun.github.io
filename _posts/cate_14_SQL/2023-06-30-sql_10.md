---
layout: post
title: SQL_10_Merge
date : 02 July 2023
category : SQL
comments : true
---


# 1. **열 합치기**
## 1) **INNER JOIN**
### (1) FROM / WHERE 
```sql
-- FROM / WHERE
SELECT 테이블_1.열_1, 테이블_2.열_2,
FROM 테이블_1, 테이블_2  
WHERE 테이블_1.KEY = 테이블_2.KEY;

-- FROM / WHERE + 테이블을 별칭 활용
-- 오라클을 포함한 일부 DBMS는 테이블을 별칭하는 'AS'를 지원하지 않기에 생략해야함.
SELECT 별칭1.열_1, 별칭2.열_2
FROM 테이블_1 (AS) 별칭1, 테이블_2 (AS) 별칭2
WHERE 별칭1.KEY = 별칭2.KEY;
```

### (2) INNER JOIN 활용 (★★★)
```sql
-- INNER JOIN 활용
SELECT 테이블_1.열_1, 테이블_2.열_2,
FROM 테이블_1 INNER JOIN 테이블_2  
ON 테이블_1.KEY = 테이블_2.KEY;

-- INNER JOIN + 테이블을 별칭 활용 
SELECT 별칭1.열_1, 별칭2.열_2
FROM 테이블_1 (AS) 별칭1 INNER JOIN 테이블_2 (AS) 별칭2
ON 별칭1.KEY = 별칭2.KEY;
```

### 예제
```sql
-- 1) 2개 테이블 결합 하기
-- 주문이력이있는 고객ID / 고객 이름 / 주문번호
SELECT CUST.CUST_ID, CUST.CUST_NM, ORD.ORDER_ID
FROM CUSTOMERS AS CUST INNER JOIN ORDERS AS ORD
ON CUST.CUST_ID = ORD.CUST_ID;

-- 2) 3개 테이블 결합 하기
-- 주문이력이있는 고객ID / 고객 이름 / 주문번호 / 판매직원ID / 판매직원 이름
---- (1) FROM / WHERE
SELECT CUST.CUST_ID, CUST.CUST_NM, ORD.ORDER_ID, ORD.EMP_ID, EMP.NM
FROM CUSTOMERS AS CUST, ORDERS AS ORD, EMPLOYEE AS EMP
WHERE
    CUST.CUST_ID = ORD.CUST_ID
    AND ORD.EMP_ID = EMP.EMP_ID

---- (2) INNER JOIN / ON !!!!
SELECT CUST.CUST_ID, CUST.CUST_NM, ORD.ORDER_ID, ORD.EMP_ID, EMP.NM
FROM
    CUSTOMERS AS CUST
    INNER JOIN ORDERS AS ORD 
    ON CUST.CUST_ID = ORD.CUST_ID
    INNER JOIN EMPLOYEE AS EMP 
    ON ORD.EMP_ID = EMP.EMP_ID
```

### TIP
 - 조인 조건(`WHERE` or `ON`)을 지정하지 않고 조인시, 곱집합이 되어, 키가 복제되어 늘어난다. 
 - 3개 이상의 테이블을 결합하는 경우, **앞에서부터 테이블이 결합된 이후 새로운 테이블이 추가되는 개념**이다. 

--- 

<br>

## 2) **OUTER JOIN**
### 1) LEFT OUTER JOIN
 : 왼쪽 테이블 기준 조인. (`OUTER`를 생략해도 무방함.)
```sql
SELECT 별칭1.열_1, 별칭2.열_2,
FROM 테이블_1 (AS) 별칭1 LEFT (OUTER) JOIN 테이블_2 (AS) 별칭2
WHERE 별칭1.KEY = 별칭2.KEY;
```

### 2) RIGHT OUTER JOIN
 : 오른쪽 테이블 기준 조인. (`OUTER`를 생략해도 무방함.)
```sql
SELECT 별칭1.열_1, 별칭2.열_2,
FROM 테이블_1 (AS) 별칭1 RIGHT (OUTER) JOIN 테이블_2 (AS) 별칭2
WHERE 별칭1.KEY = 별칭2.KEY;
```

### 3) FULL OUTER JOIN
 : 왼쪽과 오른쪽 테이블의 모든 행이 반환됨. (`OUTER`를 생략해도 무방함.)
```sql
SELECT 별칭1.열_1, 별칭2.열_2,
FROM 테이블_1 (AS) 별칭1 FULL (OUTER) JOIN 테이블_2 (AS) 별칭2
WHERE 별칭1.KEY = 별칭2.KEY;
```

 - \* `LEFT` or `RIGHT`, `FULL` OUTER JOIN시, 
   - *기준 테이블에만 값이 있고 JOIN되는 테이블엔 값이 없다면 -->  NULL값을 반환함.*  
   - *1개의 키값에 2개이상의 값이 존재하면 --> 키값이 복제되어 모든 값이 붙는다.*


### 예제
```sql
-- 1) EX
-- CUSTOMERS와 ORDERS 테이블을 이용하여, [고객ID / 고객 이름 / 주문번호]를 나타내고, 
-- 주문 이력이 있는 고객은 1, 없는 고객은 0으로 표시해보자. 
SELECT CUST.CUST_ID, CUST.CUST_NM, ORD.ORDER_ID
    CASE WHEN ORD.ORDER_ID IS NOT NULL THEN 1
    ELSE 1 END AS ORDER_FLG
FROM CUSTOMERS AS CUST LEFT JOIN ORDERS AS ORD
ON CUST.CUST_ID = ORD.CUST_ID
ORDER BY CUST.CUST_ID ;



```




















--- 

<br>


## + 연습문제
 - PPC_MAST_201312 테이블
``` 
+---------------+---------+---------+------+-------------+
| SSN           | ACCT_NO | ACCT_CD | PRFT | BALANCE_AMT |
+---------------+---------+---------+------+-------------+
| 7802221111111 | 22033   |     130 |  504 |       56746 |
| 8307153333444 | 54412   |     110 |  585 |       23540 |
| 5605099999222 | 65433   |     340 |  213 |      987800 |
| 8012301111333 | 58721   |     320 |  780 |      310000 |
| 6711032222111 | 23422   |     120 | 5679 |           3 |
| 8910103333222 | 89811   |     310 |  240 |       40011 |
| 7802221111111 | 78022   |     100 |  899 |     4565000 |
| 6711032222111 | 35714   |     300 | 3780 |     2545640 |
| 8910103333222 | 68740   |     310 |  233 |      522312 |
| 5605099999222 | 96870   |     330 | 7000 |        2158 |
| 7802221111111 | 89770   |     140 | 1000 |      566600 |
| 6711032222111 | 33270   |     130 | 5600 |       68770 |
| 7802221111111 | 87890   |     340 | 1270 |     5500000 |
+---------------+---------+---------+------+-------------+
```

```sql
-- 1-1) 자산 & 부채 테이블 생성
-- 수신(부채) 코드 : 100, 110, 120, 130, 140
-- 여신(자산) 코드 : 300, 310, 320, 330, 340
SELECT 
    CASE
        WHEN ACCT_CD IN (100, 110, 120, 130, 140) THEN 'LIABILITY'
        WHEN ACCT_CD IN (300, 310, 320, 330, 340) THEN 'ASSET'
        ELSE ACCT_CD END AS BALANCE_SHEET,
    sum(BALANCE_AMT) AS TOTAL_BALANCE_AMT
FROM PPC_MAST_201312
GROUP BY BALANCE_SHEET
ORDER BY BALANCE_SHEET ;
-- +---------------+-------------------+
-- | BALANCE_SHEET | TOTAL_BALANCE_AMT |
-- +---------------+-------------------+
-- | ASSET         |           9907921 |
-- | LIABILITY     |           5280659 |
-- +---------------+-------------------+
```

```sql
-- 2) 고객별 상품 갯수 테이블 생성
SELECT
    SSN, 
    COUNT(ACCT_NO) AS PPC
FROM PPC_MAST_201312
GROUP BY SSN
ORDER BY PPC DESC;
-- +---------------+-----+
-- | SSN           | PPC |
-- +---------------+-----+
-- | 7802221111111 |   4 |
-- | 6711032222111 |   3 |
-- | 5605099999222 |   2 |
-- | 8910103333222 |   2 |
-- | 8307153333444 |   1 |
-- | 8012301111333 |   1 |
-- +---------------+-----+
```

```sql
-- 3) 고객별 상품 갯수가 3개 이상인 고객만 추출
SELECT
    SSN, 
    COUNT(ACCT_NO) AS PPC
FROM PPC_MAST_201312
GROUP BY SSN
HAVING PPC >= 3
ORDER BY PPC DESC;
-- +---------------+-----+
-- | SSN           | PPC |
-- +---------------+-----+
-- | 7802221111111 |   4 |
-- | 6711032222111 |   3 |
-- +---------------+-----+
```

```sql
-- 4) 고객별 총수익과 PPC 테이블
SELECT SSN,
    COUNT(ACCT_NO) AS PPC,
    SUM(PRFT) AS PRFT_TOTAL
FROM PPC_MAST_201312
GROUP BY SSN
ORDER BY PPC DESC;
-- +---------------+-----+------------+
-- | SSN           | PPC | PRFT_TOTAL |
-- +---------------+-----+------------+
-- | 7802221111111 |   4 |       3673 |
-- | 6711032222111 |   3 |      15059 |
-- | 5605099999222 |   2 |       7213 |
-- | 8910103333222 |   2 |        473 |
-- | 8307153333444 |   1 |        585 |
-- | 8012301111333 |   1 |        780 |
-- +---------------+-----+------------+
```


#### Reference
- 칼퇴족 김대리는 알고 나만 모르는 SQL - 책밥
